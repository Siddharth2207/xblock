---
#tranche-space-per-second 11574074e14
#tranche-space-heal-delay 300
#base-tranche-size-sell 3500e18
#base-tranche-size-buy 17e17
#tranche-growth-factor 11e17
#base-io-ratio 111e16
#io-ratio-growth-factor 102e16
#tranche-space-key 0
#update-time-key 1
#dai 0x6B175474E89094C44Da98b954EedeAC495271d0F
#weth 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
#twap-duration 1800
#min-tranche-space-diff 1e17
#tranche-space-snap-threshold 1e16

#test-base-tranche-size !Base tranche size is the size of the smallest tranche, denominated in token.
#test-tranche-space-before !Tranche space is a decimal 18 number representing normalized tranche consumption.
#test-now !Current block timestamp.
#test-last-update-time !Last update time is the block timestamp of the last time we moved through tranche space.
#test-io-ratio-multiplier !Decimal 18 ratio as a multiplier to transform the IO ratio from the batch denomination to the orderbook vault denomination.

#last-tranche
  tranche-space-before: get(hash(order-hash() tranche-space-key)),
  last-update-time: get(hash(order-hash() update-time-key));

/**
 * To calculate a tranche without looping constructs, we have the idea of a 1D
 * tranche space that has a lower bound at 0 and we move through it linearly
 * as trades are made. Every decimal 18 unit of tranche space is a tranche.
 * The amount and price is derived from where we are in tranche space, and the
 * amount that we move through tranche space per trade is derived from real vault
 * movements.
 * Tranches are recharged at a constant rate in tranche space, which maps to a
 * non linear rate in token space, according to the derived relationship.
 */
#calculate-tranche
  base-tranche-size tranche-space-before now last-update-time:,
  recharge-duration: int-sub<1>(now int-add(last-update-time tranche-space-heal-delay)),
  recharge-tranche-space: decimal18-mul(int-to-decimal18(recharge-duration) tranche-space-per-second),
  tranche-space-now: decimal18-sub<1>(tranche-space-before recharge-tranche-space),
  tranche-space-available: decimal18-sub(1e18 decimal18-frac(tranche-space-now)),
  tranche-total-size: decimal18-mul(
    base-tranche-size
    decimal18-power(tranche-growth-factor decimal18-floor(tranche-space-now))
  );

#calculate-io
  base-tranche-size tranche-space-before now last-update-time io-ratio-multiplier:,
  tranche-space-now tranche-space-available tranche-total-size: call<'calculate-tranche 3>(base-tranche-size tranche-space-before now last-update-time),
  tranche-io-ratio: decimal18-mul(
    base-io-ratio
    decimal18-power(io-ratio-growth-factor decimal18-floor(tranche-space-now))
  ),
  tranche-available-size: decimal18-mul(tranche-total-size tranche-space-available),
  tranch-io-ratio: decimal18-mul(tranche-io-ratio io-ratio-multiplier);

#calculate-io-sell
  tranche-space-before last-update-time: call<'last-tranche 2>(),
  io-ratio-multiplier: uniswap-v3-twap-output-ratio(dai 18 weth 18 twap-duration 0 [uniswap-v3-fee-low]),
  amount io-ratio: call<'calculate-io 2>(
    base-tranche-size-sell
    tranche-space-before
    block-timestamp()
    last-update-time
    io-ratio-multiplier
  );

#calculate-io-buy
  tranche-space-before last-update-time: call<'last-tranche 2>(),
  io-ratio-multiplier: uniswap-v3-twap-output-ratio(weth 18 dai 18 twap-duration 0 [uniswap-v3-fee-low]),
  amount io-ratio: call<'calculate-io 2>(
    base-tranche-size-buy
    tranche-space-before
    block-timestamp()
    last-update-time
    io-ratio-multiplier
  );

#calculate-io-test
  amount io-ratio: call<'calculate-io 2>(
    test-base-tranche-size
    test-tranche-space-before
    test-now
    test-last-update-time
    test-io-ratio-multiplier
  );

#handle-io
  base-tranche-size:,
  tranche-space-before last-update-time: call<'last-tranche 2>(),
  tranche-space-now _ tranche-total-size: call<'calculate-tranche 3>(
    base-tranche-size
    tranche-space-before
    block-timestamp()
    last-update-time
  ),
  tranche-space-diff: decimal18-div(
    int-to-decimal18(output-vault-balance-decrease())
    int-to-decimal18(tranche-total-size)
  ),
  tranche-space-after: decimal18-add(tranche-space-now tranche-space-diff),
  /* Snap tranche space to the nearest tranche to avoid dust issues at the edges */
  tranche-space-after-snapped: decimal18-snap-to-unit(tranche-space-snap-threshold tranche-space-after),
  /* Minimum tranche movement per trade to avoid people dusting the strat to stop it recharging */
  :ensure<0>(greater-than-or-equal-to(
    decimal18-sub<1>(tranche-space-after-snapped tranche-space-now)
    min-tranche-space-diff
  )),
  :set(hash(order-hash() tranche-space-key) tranche-space-after-snapped),
  :set(hash(order-hash() update-time-key) block-timestamp());

#handle-io-sell
  :call<'handle-io 0>(base-tranche-size-sell);

#handle-io-buy
  :call<'handle-io 0>(base-tranche-size-buy);

#handle-io-test
  :call<'handle-io 0>(test-base-tranche-size);