#tranche-space-per-second 11574074e14
#tranche-space-heal-delay 3600
#base-tranche-size 1000e18
#tranche-growth-factor 11e17
#base-io-ratio 101e16
#tranche-space-key 0
#update-time-key 1

/**
 * To calculate a tranche without looping constructs, we have the idea of a 1D
 * tranche space that has a lower bound at 0 and we move through it linearly
 * as trades are made. Every decimal 18 unit of tranche space is a tranche.
 * The amount and price is derived from where we are in tranche space, and the
 * amount that we move through tranche space per trade is derived from real vault
 * movements.
 * Tranches are healed at a constant rate in tranche space, which maps to a non
 * linear rate in token space, according to the derived relationship.
 */
#calculate-tranche
  /* where are we in tranche space? */
  tranche-space-before: get(hash(order-hash() tranche-space-key)),
  last-update-time: get(hash(order-hash() update-time-key)),
  /* would be nice if we had saturating sub here */
  tranche-space-now: decimal18-sub(
    tranche-space-before  
    decimal18-min(
      tranche-space-before
      decimal18-mul(
        decimal18-scale18<0>(
          int-sub(
            int-max(
              int-sub(block-timestamp() tranche-space-heal-delay)
              last-update-time
            )
            last-update-time
          )
        )
        tranche-space-per-second
      )
    )
  ),
  tranche-space-available: decimal18-sub(
    1e18
    decimal18-frac(tranche-space-now)
  ),
  tranche-total-size: decimal18-mul(
    base-tranche-size
    decimal18-power(tranche-growth-factor decimal18-floor(tranche-space-now))
  );

#calculate-io
  tranche-space-now
  tranche-space-available
  tranche-total-size: call<'calculate-tranche 3>(),
  tranche-available-size: decimal18-mul(
    tranche-total-size
    tranche-space-available
  ),
  tranche-io-ratio: decimal18-power(
    base-io-ratio
    decimal18-floor(tranche-space-now)
  );

#handle-io
  /* move in tranche space */
  tranche-space-now
  _
  tranche-total-size: call<'calculate-tranche 3>(),
  /* the int add here is a hack because we dont have decimal 18 div that rounds up */
  tranche-space-diff: decimal18-div(
    decimal18-scale18<0>(output-vault-balance-decrease())
    decimal18-scale18<0>(tranche-total-size)
  ),
  tranche-space-diff-snapped: if(
    less-than(decimal18-sub(decimal18-ceil(tranche-space-diff) tranche-space-diff) 1e16)
    decimal18-ceil(tranche-space-diff)
    tranche-space-diff
  ),
  tranche-space-after: decimal18-add(
    tranche-space-now
    tranche-space-diff-snapped
  ),
  :set(hash(order-hash() tranche-space-key) tranche-space-after),
  :set(hash(order-hash() update-time-key) block-timestamp());
