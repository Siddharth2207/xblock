#tranche-space-per-second 11574074e14
#tranche-space-heal-delay 3600
#base-tranche-size 1000e18
#tranche-growth-factor 11e17
#base-io-ratio 111e16
#io-ratio-growth-factor 105e16
#tranche-space-key 0
#update-time-key 1
#dai 0x6B175474E89094C44Da98b954EedeAC495271d0F
#weth 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2
#twap-duration 3600
#test-tranche-space-before !Tranche space is a decimal 18 number representing normalized tranche consumption.
#test-now !Current block timestamp.
#test-last-update-time !Last update time is the block timestamp of the last time we moved through tranche space.
#test-io-ratio-multiplier !Decimal 18 ratio as a multiplier to transform the IO ratio from the batch denomination to the orderbook vault denomination.

#last-tranche
  tranche-space-before: get(hash(order-hash() tranche-space-key)),
  last-update-time: get(hash(order-hash() update-time-key));

/**
 * To calculate a tranche without looping constructs, we have the idea of a 1D
 * tranche space that has a lower bound at 0 and we move through it linearly
 * as trades are made. Every decimal 18 unit of tranche space is a tranche.
 * The amount and price is derived from where we are in tranche space, and the
 * amount that we move through tranche space per trade is derived from real vault
 * movements.
 * Tranches are recharged at a constant rate in tranche space, which maps to a
 * non linear rate in token space, according to the derived relationship.
 */
#calculate-tranche
  tranche-space-before
  now
  last-update-time:,
  recharge-duration: int-sub<1>(now int-add(last-update-time tranche-space-heal-delay)),
  recharge-tranche-space: decimal18-mul(decimal18-scale18<0>(recharge-duration) tranche-space-per-second),
  tranche-space-now: decimal18-sub<1>(tranche-space-before recharge-tranche-space),
  tranche-space-available: decimal18-sub(1e18 decimal18-frac(tranche-space-now)),
  tranche-total-size: decimal18-mul(
    base-tranche-size
    decimal18-power(tranche-growth-factor decimal18-floor(tranche-space-now))
  );

#calculate-io
  tranche-space-before
  now
  last-update-time
  io-ratio-multiplier:,
  tranche-space-now
  tranche-space-available
  tranche-total-size: call<'calculate-tranche 3>(tranche-space-before now last-update-time),
  tranche-io-ratio: decimal18-mul(
    base-io-ratio
    decimal18-power(io-ratio-growth-factor decimal18-floor(tranche-space-now))
  ),
  tranche-available-size: decimal18-mul(tranche-total-size tranche-space-available),
  eth-tranch-io-ratio: decimal18-mul(tranche-io-ratio io-ratio-multiplier);

#calculate-io-sell
  tranche-space-before
  last-update-time: call<'last-tranche 2>(),
  io-ratio-multiplier: uniswap-v3-twap-output-ratio(dai 18 weth 18 twap-duration 0 [uniswap-v3-fee-low]),
  amount io-ratio: call<'calculate-io 2>(
    tranche-space-before
    block-timestamp()
    last-update-time
    io-ratio-multiplier
  );

#calculate-io-buy
  tranche-space-before
  last-update-time: call<'last-tranche 2>(),
  io-ratio-multiplier: uniswap-v3-twap-output-ratio(weth 18 dai 18 twap-duration 0 [uniswap-v3-fee-low]),
  amount io-ratio: call<'calculate-io 2>(
    tranche-space-before
    block-timestamp()
    last-update-time
    io-ratio-multiplier
  );

#calculate-io-test
  amount io-ratio: call<'calculate-io 2>(
    test-tranche-space-before
    test-now
    test-last-update-time
    test-io-ratio-multiplier
  );

#handle-io
  tranche-space-before
  last-update-time: call<'last-tranche 2>(),
  tranche-space-now
  _
  tranche-total-size: call<'calculate-tranche 3>(
    tranche-space-before
    block-timestamp()
    last-update-time
  ),
  tranche-space-diff: decimal18-div(
    decimal18-scale18<0>(output-vault-balance-decrease())
    decimal18-scale18<0>(tranche-total-size)
  ),
  tranche-space-after: decimal18-add(tranche-space-now tranche-space-diff),
  tranche-space-after-snapped: decimal18-snap-to-unit(1e16 tranche-space-after),
  :set(hash(order-hash() tranche-space-key) tranche-space-after-snapped),
  :set(hash(order-hash() update-time-key) block-timestamp());